#pragma once
namespace gameFonts
{
#define FONT_BOLD				"fonts/720/boldFont"
#define FONT_NORMAL				"fonts/normalFont"
}

bool IsOpen;
const char* Submenu;
float scroller = 208;
float SizeHud = 200;
int Scroll;
int MaxScroll;
const float* OptionColour[100];
const char* OptionText[100];
int cooldown = 0;
int slider;

namespace pointers
{
	structures::opd_s Material_RegisterHandle_s = { 0x004C6D28, TOC };
	structures::opd_s Cbuf_AddTextC = { 0x1D9EC0, TOC };
	structures::opd_s R_AddCmdDrawStretchPic_s = { 0x004C7168, TOC };
	structures::opd_s AimTarget_GetTagPos_t = { 0x006FAA78, TOC }; //could be 0x00013460
	//structures::opd_s GetWeaponDef_t = { 0x006FB1E0, TOC };
	//structures::opd_s SL_GetString_t = { 0x1FEE88, TOC };
	structures::opd_s CG_DrawRotatedPicPhysical_t = { 0x006FBB60, TOC };
	structures::opd_s AimTarget_isTargetVisible_t = { 0x0013500, TOC };
	structures::opd_s CG_IsEntityFriendlyNotEnemy_t = { 0x00587D10, TOC };
	structures::opd_s UI_drawTextWithGlow_t = { 0x4C7258 , TOC };
	//int(*GetWeaponDef)(int Weapon) = (int(*)(int)) & GetWeaponDef_t;
	//void UI_drawTextWithEffects(char const *, int, FONT_NORMA, float, float, float, float, float const * const, int, float const * const, void *, void *, int, int, int, int);
	bool(*CG_IsEntityFriendlyNotEnemy)(int LocalClient, int Centity) = (bool(*)(int, int)) & CG_IsEntityFriendlyNotEnemy_t;
	bool(*AimTarget_isTargetVisible)(int LocalClient, int Centity) = (bool(*)(int, int)) & AimTarget_isTargetVisible_t;
	//int(*SL_GetString)(const char* str) = (int(*)(const char*)) & SL_GetString_t;
	int(*Material_RegisterHandle)(const char* name, int imageTrack) = (int(*)(const char*, int))0x004C6D28;
	void(*CG_DrawRotatedPicPhysical)(int, float, float, float, float, float, const float*, void*) = (void(*)(int, float, float, float, float, float, const float*, void*)) & CG_DrawRotatedPicPhysical_t;
	void* (*R_RegisterMaterial)(const char* font, int imageTrac) = (void* (*)(const char*, int)) & Material_RegisterHandle_s;
	void(*R_AddCmdDrawStretchPic)(float x, float y, float width, float height, float xScale, float yScale, float xay, float yay, const float* color, void* material) = (void(*)(float x, float y, float width, float height, float xScale, float yScale, float xay, float yay, const float* color, void* material)) & R_AddCmdDrawStretchPic_s;
	int R_AddCmdDrawText_t[2] = { 0x004C7248, TOC };
	int(*CL_RegisterFont)(const char* font, int imageTrack) = (int(*)(const char*, int))0x006FD5B0;
	void(*R_AddCmdDrawText)(const char* text, int maxChars, int font, float x, float y, float xScale, float yScale, float rotation, const float* color, int style) = (void(*)(const char*, int, int, float, float, float, float, float, const float*, int)) & R_AddCmdDrawText_t;
	void(*Cbuf_AddText)(int Client, const char* Command) = (void(*)(int, const char*)) & pointers::Cbuf_AddTextC;
	int va_t[2] = { 0x0070E5E0, TOC };
	bool(*AimTarget_GetTagPos)(int targ_centity, unsigned tagIndex, float* pos) = (bool(*)(int, unsigned int, float*)) & AimTarget_GetTagPos_t;
	char* (*va)(const char* fmt, ...) = (char* (*)(const char*, ...)) & va_t;
	structures::opd_s R_TextWidth_t = { 0x004C6D48, TOC };
	int(*R_TextWidths)(const char* text, int maxChars, int font) = (int(*)(const char*, int, int)) & R_TextWidth_t;
	float R_TextWidth(const char* Text, const char* font, float xScale)
	{
		return ((float)R_TextWidths(Text, 0x7FFFFFFF, CL_RegisterFont(font, 0)) * xScale);
	}
	typedef Font_s* (*RegisterFont_t)(const char* name, int img);
	RegisterFont_t RegisterFont = RegisterFont_t(0x006FD5B0);
	structures::opd_s Com_GetClientDObj_t = { 0x1E59A0, TOC };
	int(*Com_GetClientDObj)(int handle, int localClientNum) = (int(*)(int, int)) & Com_GetClientDObj_t;

	structures::opd_s DObjGWTP = { 0x52738, TOC };
	bool(*CG_DObjGetWorldTagPos)(c_entity_t* targ_centity, unsigned int dobj, unsigned int tagIndex, Vector3* pos) = (bool(*)(c_entity_t*, unsigned int, unsigned int, Vector3*)) & DObjGWTP;


	structures::opd_s SL_GetString_t = { 0x2013A8, TOC };
	int(*SL_GetString)(const char* str, int user) = (int(*)(const char*, int)) & SL_GetString_t;
	structures::opd_s R_AddCmdDrawStretchPicRotateXY_t = { 0x4C7158, TOC };
	void(*R_AddCmdDrawStretchPicRotateXY)(float x, float y, float w, float h, float xScale, float yScale, float xay, float yay, float Angle, float* color, int material) = (void(*)(float, float, float, float, float, float, float, float, float, float*, int)) & R_AddCmdDrawStretchPicRotateXY_t;

	structures::opd_s Dvar_GetBool_t = { 0x277138, TOC };
	bool(*Dvar_GetBool)(const char* dvarName) = (bool(*)(const char*)) & Dvar_GetBool_t;
	structures::opd_s Atan_t = { 0x4C6CC8, TOC };
	double(*Atan)(double y, double x) = (double(*)(double, double)) & Atan_t;

	int Material_RegisterHandle_t[2] = { 0x004C6D28, TOC };
	int(*MaterialRegisterHandle)(const char* material, int imageTrack) = (int(*)(const char*, int)) & Material_RegisterHandle_t;

	structures::opd_s BG_GetWeaponDef_t = { 0x32898 ,TOC };
	int(*GetWeaponDef)(int weapon) = (int(*)(int)) & BG_GetWeaponDef_t;
	WeaponDef* (*GetWeaponDefWD)(int weapon) = (WeaponDef * (*)(int)) & BG_GetWeaponDef_t;

	structures::opd_s bulletTrace_t = { 0x8A6C8, TOC };
	bool(*bulletTrace)(int local, BulletFireParams* BulletFireParams, int weaponDef, c_entity_t* entity, BulletTraceResults* bulletTraceResultsype, int lastSurfaceType) = (bool(*)(int, BulletFireParams*, int, c_entity_t*, BulletTraceResults*, int)) & bulletTrace_t;

	structures::opd_s BG_GetSurfacePenetrationDepthF_t = { 0x32850, TOC };
	float(*BG_GetSurfacePenetrationDepthF)(int penetrateType, int surfaceFlags) = (float(*)(int, int)) & BG_GetSurfacePenetrationDepthF_t;

	structures::opd_s _BG_AdvanceTrace_t = { 0x34D50, TOC };
	bool(*BG_AdvanceTrace)(BulletFireParams* bulletFireParams, BulletTraceResults* bulletTraceResults, float amount) = (bool(*)(BulletFireParams*, BulletTraceResults*, float)) & _BG_AdvanceTrace_t;
	structures::opd_s BG_GetSpreadForWeapon_t = { 0x335D8 ,TOC };
	void(*BG_GetSpreadForWeapon)(cgArray_t* PlayerState, int cgArray, float* min, float* max) = (void(*)(cgArray_t * PlayerState, int cgArray, float* min, float* max)) & BG_GetSpreadForWeapon_t;


	structures::opd_s CG_CompassDrawPlayerMap_t = { 0x3E608,TOC };
	void* (*CG_CompassDrawPlayerMap)(int localClientNum, CompassType compassType, rectDef_s* size, rectDef_s* rect, int material, const float* color) = (void* (*)(int, CompassType, rectDef_s*, rectDef_s*, int, const float*)) & CG_CompassDrawPlayerMap_t;

	structures::opd_s CG_GetPlayerViewOrigin_t = { 0x8BD20 ,TOC };
	void(*CG_GetPlayerViewOrigin)(int localClientNum, cgArray_t* cgs, Vector3& origin) = (void(*)(int, cgArray_t*, Vector3&)) & CG_GetPlayerViewOrigin_t;
	structures::opd_s Dvar_GetString_s = { 0x276F60 ,TOC };
	const char* (*Dvar_GetString)(const char* Dvar) = (const char* (*)(const char* Dvar)) & Dvar_GetString_s;

	structures::opd_s Trace_GetEntityHitIDs_t = { 0x1D1240 ,TOC };
	int(*Trace_GetEntityHitIDs)(BulletTraceResults* result) = (int(*)(BulletTraceResults*)) & Trace_GetEntityHitIDs_t;

	structures::opd_s Dvar_FindVar_t = { 0x2762C8, TOC };
	dvar_t*(*Dvar_FindVar)(const char* variable) = (dvar_t*(*)(const char*)) & Dvar_FindVar_t;

	structures::opd_s CL_AllLocalClientsDisconnected_t = { 0x0DCD00, TOC };
	bool(*CL_AllLocalClientsDisconnected) = (bool(*)) & CL_AllLocalClientsDisconnected_t;

	bool in_game() {
		return Dvar_GetBool("cl_ingame");
	}
}
int getLocalName()
{
	return (0x01f9f11c);
}
char* getName(int index) {
	char* Name = (char*)(0x00a1359a + 0xd8 * index);
	if (strcmp(Name, ""))
		return Name;
	else
		return "Empty";
}

namespace Bools
{
	bool Aimbot = false;//true when aimbot enabled
	bool Required = false;//true when you have to aim down sight
	bool shootToEnable = false;//true if r1 makes it work
	int aimbotType = 0; //0 = legit, 1 = rage
	bool autoShoot = false;//makes you shoot when a player is visible
	bool autoAim = false;//makes you aim when a client is visible
	bool semiAutoMode = false;
	int targetBone = 0;
	bool isCurrentlyShooting = false;
	bool UnfairAimbot = false;//overrides the rest. Kills closest person when you shoot
	bool silentAimbot = false;//not really used YET
	bool autoWall = false;
	bool aimLock = false;
	int autoWallStrength = 0;
	bool antiHeadGlitch = false;
	bool AutoBone = false; //spicey shit yess
	int autoBoneStrength = 0;
	int autowall_strength = 0;
	bool legitbotFov = 50;
	float aimbotSmooth = 5.f;
	bool ForceHost = false;
	int setPrestige = 0;
	bool compassArrows = false;
	bool InfAmmo = false;
	bool noFlinch = false;
	bool setCheck;
	bool Radar = false;
	int RadarScaling = 1;
	bool RedBox = false;
	bool UAV = false;
	bool NoRecoil = false;
	bool Laser = false;
	bool Wallhack = false;
	bool FastAim = false;
	bool Glow = false;
	bool NoSpread = false;
	float FOV = 65;
	bool NoFX = false;
	bool L33T = false;
	bool ThirdPerson = false;
	bool NoSway = false;
	bool MapRotation = false;
	bool ShowNames = false;
	bool DebugMode = false;
	bool LeftGun = false;
	bool Contrast = false;
	bool Contrast1 = false;
	bool FPS = false;

	bool Godmode = false;
	bool NoClip = false;

	bool DynamicHealthBar = false;
	bool AllPerks = false;
	bool X2speed = false;
	bool Jumpheight = false;
	bool SuperMelee = false;
	bool EnableESP = false;
	bool enemyESP = false;
	bool teamESP = false;
	bool ESP = false;

	bool should_draw_esp = false;
	bool should_draw_radar = false;
	bool bone_esp = false;
	int box_esp = 0;
	bool health_esp = false;
	bool vangles = false;
	int snap_lines = 0;
	bool name_esp = false;
	bool flag_esp = false;

	bool serverInformation = false;

	bool enableAntiAim = false;
	int aa_pitch = 0;
	int aa_yaw = 0;

	bool WallHacks = false;
	bool EntityWAll = false;


	bool targetInformation = false;


	bool customCrosshair = false;
	bool removeOriginalCrosshair = false;
	bool fadeColorDependingOnSpread = false;
	bool modulateCrosshair = false;

	bool removeFog = false;
	bool fullbright = false;

	int cpu_temp;
	int rsx_temp;

	int max_scroll;

	bool has_hit_trace;
	float trace_fraction;

	bool customCamo = false;
	bool customCamoFlash = false;

	bool disableDLC = false;

	bool setMenuPosAuto = false;
}

namespace MenuSettings
{

	int xHud = 440;
	int YHud = 135;
	int YHud2 = 115;
	int YHud3 = 60;
	int menuWidth = 400;
	int menuHeight = 292;
	int menuThickness = 1;
	int BaseMenuHeight = 62;

	bool MenuFlash = false;
	int MenuFlashSpeed = 1;
}

void ResetMenuPos()
{
	MenuSettings::xHud = 440;
	MenuSettings::YHud = 135;
}

namespace data {
	bool menuOpen;
	int menuTimer, curScroll[8], maxScroll;
	char* curMenu = "Main Menu";
	int maxOptions = 9;
	int sub_tabs = 0;
	int ScrollInt;
	int MaxScrollInt = 7;
	int radar_height = 0;
	float menuAlpha = 0.f;
	float controlAlpha[255];
	float toggleAlpha[255];
	char* menu_preview[255];
	int scrollData;
	float sliderData[255];
	int lastMenuSize;
}

namespace menuFunctions
{

	void  DrawText(const char* text, float x, float y, char* font, float fontSize, menuColors::Color color)
	{
		//	float black[4] = { 0.f, 0.f, 0.f, color.a };
		//	pointers::R_AddCmdDrawText(text, 0x7FFFFFFF, pointers::CL_RegisterFont(font, 0), x + 1, y + 1, fontSize, fontSize, 0, black, 0);
		pointers::R_AddCmdDrawText(text, 0x7FFFFFFF, pointers::CL_RegisterFont(font, 0), x, y, fontSize, fontSize, 0, (float*)&color, 3);
	}

	void DrawShader(float x, float y, float width, float height, menuColors::Color color, const char* material) {
		//	pointers::R_AddCmdDrawStretchPic(x - 1, y - 1, width + 2, height + 2, 1, 1, 1, 1, (float*)&menuColors::menuDimmedBlack, pointers::R_RegisterMaterial(material, 0));
		pointers::R_AddCmdDrawStretchPic(x, y, width, height, 1, 1, 1, 1, (float*)&color, pointers::R_RegisterMaterial(material, 0));
	}
	void UiDrawShader(float x, float y, float width, float height, float angle, menuColors::Color col, char* shader) {
		pointers::R_AddCmdDrawStretchPicRotateXY(x, y, width, height, 0, 0, 1, 1, angle, (float*)&col, pointers::MaterialRegisterHandle(shader, 0));
	}
	void CL_DrawTextWithShader(const char* text, int maxChars, char* font, float x, float y, float rotation, float xScale, float yScale, float* color, float* color2, int style, bool outlined) {
		float text_width = pointers::R_TextWidth(text, font, xScale);
		float font_height = pointers::RegisterFont(font, 7)->pixelHeight;
		float shader_x = x, shader_y = y, shader_width = text_width + 6.0f, shader_height = ((font_height + 4) * yScale) + 5.0f;
		float text_x = x + 3.0f, text_y = y + 1.0f + ((font_height + 4) * yScale);

		if (outlined) {
			pointers::R_AddCmdDrawStretchPic(shader_x - 1, shader_y - 1, shader_width + (1 * 2), 1, 0, 0, 1, 1, color2, pointers::R_RegisterMaterial("White", 0)); // Top>
			pointers::R_AddCmdDrawStretchPic(shader_x - 1, shader_y - 1, shader_width + (1 * 2), 1, 0, 0, 1, 1, color2, pointers::R_RegisterMaterial("White", 0)); // Top<

			pointers::R_AddCmdDrawStretchPic(shader_x - 1, shader_y + shader_height, shader_width + (1 * 2), 1, 0, 0, 1, 1, color2, pointers::R_RegisterMaterial("White", 0)); // Bottom>
			pointers::R_AddCmdDrawStretchPic(shader_x - 1, shader_y + shader_height, shader_width + (1 * 2), 1, 0, 0, 1, 1, color2, pointers::R_RegisterMaterial("White", 0)); // Bottom<

			pointers::R_AddCmdDrawStretchPic(shader_x - 1, shader_y - 1, 1, shader_height + 1, 0, 0, 1, 1, color2, pointers::R_RegisterMaterial("White", 0)); // Left>
			pointers::R_AddCmdDrawStretchPic(shader_x - 1, shader_y - 1, 1, shader_height + 1, 0, 0, 1, 1, color2, pointers::R_RegisterMaterial("White", 0)); // Left<
			pointers::R_AddCmdDrawStretchPic(shader_x + shader_width, shader_y - 1, 1, shader_height + (1 * 2), 0, 0, 1, 1, color2, pointers::R_RegisterMaterial("White", 0)); // Right>
			pointers::R_AddCmdDrawStretchPic(shader_x + shader_width, shader_y - 1, 1, shader_height + (1 * 2), 0, 0, 1, 1, color2, pointers::R_RegisterMaterial("White", 0)); // Right<
		}

		float black_lol[4] = { 0.f, 0.f, 0.f, 0.5f };
		pointers::R_AddCmdDrawStretchPic(shader_x, shader_y, shader_width, shader_height, 0.0f, 0.0f, 1.0f, 1.0f, black_lol, pointers::R_RegisterMaterial("White", 0));
		DrawText(text, text_x, text_y, FONT_NORMAL, xScale, *(menuColors::Color*)color);
	}
	void DrawShaderWithText(int x, int y, float size, const char* text, menuColors::Color text_color, bool outline, menuColors::Color outline_color) {
		CL_DrawTextWithShader(text, 0x7F, FONT_NORMAL, x, y, 0.f, size, size, (float*)&text_color, (float*)&outline_color, 0, outline);
	}
	Vector2 TextSize(const char* text, float Scale) {
		float x = pointers::R_TextWidth(text, FONT_NORMAL, Scale);
		float y = (pointers::RegisterFont(FONT_NORMAL, 7)->pixelHeight + 4) * Scale;
		return Vector2(x, y);
	}
	void DrawRainbowLine(float x, float y, float width, float height, menuColors::Color colorl, menuColors::Color colorr)
	{
		pointers::R_AddCmdDrawStretchPic(x, y, width, height, 0.0f, 0.0f, 1.0f, 1.0f, (float*)&colorl, pointers::R_RegisterMaterial("gradient_fadein", 0));
		pointers::R_AddCmdDrawStretchPic(x, y, width, height, 1.0f, 0.0f, 0.0f, 0.0f, (float*)&colorr, pointers::R_RegisterMaterial("gradient_fadein", 0));
	}

	void DrawShaderWithOutline(float x, float y, float w, float h, menuColors::Color outlineColor, menuColors::Color backgroundColor, float lineWidth) {

		DrawShader(x, y, lineWidth, h, outlineColor, "white");
		DrawShader(x + lineWidth, y, w - lineWidth, lineWidth, outlineColor, "white");
		DrawShader(x + lineWidth, y + h - lineWidth, w - (lineWidth * 2), lineWidth, outlineColor, "white");
		DrawShader(x + w - lineWidth, y + lineWidth, lineWidth, h - lineWidth, outlineColor, "white");
		DrawShader(x + lineWidth, y + lineWidth, w - (lineWidth * 2), h - (lineWidth * 2), backgroundColor, "white");
	}

	//void draw_triangle(Vector2 pos, Vector2 pos2, Vector2 pos3, int horz, int vert, vec4_t color, Material* material)
	/*{
		auto scrPlace = pointers::ScrPlace_GetView(0);

		vec2_t verts[4] = { pos, pos2, pos3, pos };

		verts[0].x = ScrPlace_ApplyRectX(scrPlace, pos.x, horz);
		verts[0].y = ScrPlace_ApplyRectY(scrPlace, pos.y, vert);
		verts[1].x = ScrPlace_ApplyRectX(scrPlace, pos2.x, horz);
		verts[1].y = ScrPlace_ApplyRectY(scrPlace, pos2.y, vert);
		verts[2].x = ScrPlace_ApplyRectX(scrPlace, pos3.x, horz);
		verts[2].y = ScrPlace_ApplyRectY(scrPlace, pos3.y, vert);
		verts[3].x = verts[0].x;
		verts[3].y = verts[0].y;

		R_AddCmdDrawQuadPicWInternal(verts, 1.0f, &color, *game_white);
	}*/
	void DrawMenu(const char* menuname, const char* byWhoName, float x, float y, float width, float height, char* Material, menuColors::Color color, bool Flash)
	{
		Vector2 menuname_size = TextSize(menuname, 0.6);

		if (MenuSettings::MenuFlash)
		{
			menuFunctions::DrawShader(x - 1, y - 1, width + 2, height + 2, menuColors::menuDimmedBlack, "White"); //Fill
			menuFunctions::DrawRainbowLine(x, y, width, 20, menuColors::dflash2, menuColors::dflash); // top for text
			menuFunctions::DrawText(menuname, x + (width / 2) - (menuname_size.x / 2), y + menuname_size.y - 3, FONT_NORMAL, 0.6, menuColors::menuWhite); //menu title name
			menuFunctions::DrawText(byWhoName, x + width - 50, y + 17, FONT_NORMAL, 0.4, menuColors::menuWhite); //by who name text
			menuFunctions::DrawRainbowLine(x, MenuSettings::YHud + 42, width, 5, menuColors::dflash2, menuColors::dflash);
			menuFunctions::DrawRainbowLine(x, y + height - 5, width, 5, menuColors::dflash2, menuColors::dflash);
		}
		else {
			char cur_scroll[128];
			snprintf(cur_scroll, 128, "%i/%i", data::curScroll[data::ScrollInt], Bools::max_scroll);
			Vector2 cur_scroll_size = TextSize(cur_scroll, 0.4);
			menuFunctions::DrawShader(x - 1, y - 1, width + 2, height + cur_scroll_size.y - 1, menuColors::menuDimmedBlack, "White"); //Fill
			menuFunctions::DrawShader(x, y, width, 20, color, Material); // top for text
			menuFunctions::DrawText(menuname, x + (width / 2) - (menuname_size.x / 2), y + menuname_size.y - 3, FONT_NORMAL, 0.6, menuColors::menuWhite); //menu title name
			menuFunctions::DrawText(byWhoName, x + width - 50, y + 17, FONT_NORMAL, 0.4, menuColors::menuWhite); //by who name text
			menuFunctions::DrawShader(x, MenuSettings::YHud + 42, width, 5, color, Material);

			menuFunctions::DrawShader(x, y + height - 5, width, 2 + cur_scroll_size.y, color, Material);
			menuFunctions::DrawText(cur_scroll, x + width - 3 - cur_scroll_size.x, y + height + cur_scroll_size.y - 5, FONT_NORMAL, 0.4, menuColors::menuWhite);
			menuColors::Color hint_color = { 1, 1, 1, data::controlAlpha[data::curScroll[data::ScrollInt]] * data::menuAlpha };
			if (data::menu_preview[data::curScroll[data::ScrollInt]] != "no preview")
				menuFunctions::DrawText(data::menu_preview[data::curScroll[data::ScrollInt]], x + 3, y + height + cur_scroll_size.y - 5, FONT_NORMAL, 0.4, hint_color);


		}

	}
	inline float out_cubic(float t)
	{
		return 1 + (--t) * t * t;
	}
	void drawOption(char* Option, char* hint = "no preview") {
		data::maxScroll++;
		bool hov = (data::curScroll[data::ScrollInt] == data::maxScroll);
		if (hov && data::controlAlpha[data::maxScroll] < 1.f)
		{
			data::controlAlpha[data::maxScroll] += 0.05f;
		}
		else if (!hov) {

			if (data::controlAlpha[data::maxScroll] > 0.f)
				data::controlAlpha[data::maxScroll] -= 0.05f;
		}

		if (hov)
			data::menu_preview[data::curScroll[data::ScrollInt]] = hint;

		float eased = out_cubic(data::controlAlpha[data::maxScroll]);
		menuColors::Color super_cool_animation = { 1, 1, 1, data::controlAlpha[data::maxScroll] * data::menuAlpha };
		menuFunctions::DrawText(Option, MenuSettings::xHud + 5 + (eased * 5), ((data::maxScroll * 20) + MenuSettings::YHud + 49), FONT_NORMAL, 0.5, menuColors::menuDimmedWhite);
		menuFunctions::DrawText(Option, MenuSettings::xHud + 5 + (eased * 5), ((data::maxScroll * 20) + MenuSettings::YHud + 49), FONT_NORMAL, 0.5, super_cool_animation);
	}
	void drawSubtab(char* option, char* hint = "no preview") {
		drawOption(option, hint);
		Vector2 size = TextSize(">", 0.5);
		menuFunctions::DrawText(">", MenuSettings::xHud + MenuSettings::menuWidth - 15 - size.x, ((data::maxScroll * 20) + MenuSettings::YHud + 49), FONT_NORMAL, 0.5, menuColors::menuWhite);
	}
	void drawColorRenderOption(char* option, menuColors::Color col, char* hint = "no preview") {
		drawOption(option, hint);

		menuColors::Color menu_grey = { 15 / 255.f, 15 / 255.f, 15 / 255.f, data::menuAlpha };
		menuFunctions::DrawShader(MenuSettings::xHud + MenuSettings::menuWidth - 31, ((data::maxScroll * 20) + MenuSettings::YHud + 37), 15, 10, menu_grey, "white");


		menuColors::Color col_ = { col.r, col.g, col.b, data::menuAlpha };
		menuFunctions::DrawShader(MenuSettings::xHud + MenuSettings::menuWidth - 30, ((data::maxScroll * 20) + MenuSettings::YHud + 38), 13, 8, col_, "white");

	}
	void drawBoolOption(char* Option, bool boolToggle, char* hint = "no preview")
	{
		drawOption(Option, hint);

		menuColors::Color menu_grey = { 15 / 255.f, 15 / 255.f, 15 / 255.f, data::menuAlpha };
		menuFunctions::DrawShader(MenuSettings::xHud + MenuSettings::menuWidth - 31, ((data::maxScroll * 20) + MenuSettings::YHud + 37), 15, 10, menu_grey, "white");

		if (boolToggle && data::toggleAlpha[data::maxScroll] < 1.f)
		{
			data::toggleAlpha[data::maxScroll] += 0.05f;
		}
		else if (!boolToggle) {

			if (data::toggleAlpha[data::maxScroll] > 0.f)
				data::toggleAlpha[data::maxScroll] -= 0.05f;
		}
		if (MenuSettings::MenuFlash)
		{
			menuFunctions::DrawRainbowLine(MenuSettings::xHud + MenuSettings::menuWidth - 30, ((data::maxScroll * 20) + MenuSettings::YHud + 38), 13, 8, boolToggle ? menuColors::dflash2 : menuColors::FadedPink, boolToggle ? menuColors::dflash : menuColors::FadedPink);
		}
		else {
			menuColors::Color col = { menuColors::menuMain.r, menuColors::menuMain.g, menuColors::menuMain.b,data::menuAlpha * data::toggleAlpha[data::maxScroll] };
			menuFunctions::DrawShader(MenuSettings::xHud + MenuSettings::menuWidth - 30, ((data::maxScroll * 20) + MenuSettings::YHud + 38), 13, 8, col, "white");
		}
	}
	void drawIntOption(int value, int min, int max, char* Option)
	{
		drawOption(pointers::va("%s - %i", Option, value));

		int yDiff = 89; //YPos of the first bool
		int yBuff = 23; //Spacing between bools
		int X = ((value - min) * 75) / (max - min);

		if ((data::curScroll[data::ScrollInt] <= data::maxOptions && data::maxScroll <= data::maxOptions) || ((data::maxScroll > (data::curScroll[data::ScrollInt] - data::maxOptions)) && data::maxScroll <= data::curScroll[data::ScrollInt]))
		{
			//menuFunctions::DrawShader(MenuSettings::xHud + MenuSettings::menuWidth - 90, (data::curScroll[data::ScrollInt] <= data::maxOptions && data::maxScroll <= data::maxOptions) ? ((data::maxScroll * yBuff) + yDiff) : (((data::maxScroll - (data::curScroll[data::ScrollInt] - data::maxOptions)) * yBuff) + yDiff), 75, 10, menuColors::menuMainColor2, "white");
			menuFunctions::DrawShader(MenuSettings::xHud + MenuSettings::menuWidth - 90, (data::curScroll[data::ScrollInt] <= data::maxOptions && data::maxScroll <= data::maxOptions) ? ((data::maxScroll * yBuff) + yDiff) : (((data::maxScroll - (data::curScroll[data::ScrollInt] - data::maxOptions)) * yBuff) + yDiff), X - 2, 10, menuColors::menuWhite, "white");
		}
	}

	void DrawColorpickerOption(char* option, float hsv) {
		static menuColors::Color hues[] = { {1, 0, 0, 1},{1, 1, 0, 1}, {0, 1, 0, 1}, {0, 1, 1, 1},
			{0, 0, 1, 1}, {1, 0, 1, 1}, {1, 0, 0, 1} };

		drawOption(option);

		int width = 80;
		int height = 14;
		//	menuFunctions::DrawShader(MenuSettings::xHud + MenuSettings::menuWidth - 25 - width, ((data::maxScroll * 20) + MenuSettings::YHud + 37), 15, 10, menu_grey, "white");
		for (int i = 0; i < 6; i++)
			menuFunctions::DrawRainbowLine(MenuSettings::xHud + MenuSettings::menuWidth - 15 - width + ((width / 6) * i), ((data::maxScroll * 20) + MenuSettings::YHud + 34), width / 6, height, hues[i + 1], hues[i]);

		menuFunctions::DrawShader(MenuSettings::xHud + MenuSettings::menuWidth - 15 - width + ((width - 4) * hsv), ((data::maxScroll * 20) + MenuSettings::YHud + 34), 2, height, menuColors::menuMain, "white");

		menuFunctions::DrawShader(MenuSettings::xHud + MenuSettings::menuWidth - 15 - width - 5 - 15, ((data::maxScroll * 20) + MenuSettings::YHud + 34), 15, height, menuColors::hsvToColor(hsv), "white");
	}
	void DrawColIntOption(char* option, float col, int rgb_cur, char* hint = "no preview") {

		drawOption(option, hint);

		int width = 80;
		int height = 14;
		//	menuFunctions::DrawShader(MenuSettings::xHud + MenuSettings::menuWidth - 25 - width, ((data::maxScroll * 20) + MenuSettings::YHud + 37), 15, 10, menu_grey, "white");
		menuColors::Color grey = { 19 / 255.f, 19 / 255.f, 19 / 255.f, data::menuAlpha };
		menuColors::Color red = { 1, 0, 0, data::menuAlpha };
		menuColors::Color green = { 0, 1, 0, data::menuAlpha };
		menuColors::Color blue = { 0, 0, 1, data::menuAlpha };
		menuFunctions::DrawShader(MenuSettings::xHud + MenuSettings::menuWidth - 15 - width, ((data::maxScroll * 20) + MenuSettings::YHud + 34), width, height, grey, "white");
		menuFunctions::DrawRainbowLine(MenuSettings::xHud + MenuSettings::menuWidth - 15 - width, ((data::maxScroll * 20) + MenuSettings::YHud + 34), width / 2, height, rgb_cur == 0 ? red : rgb_cur == 1 ? green : blue, grey);
		menuFunctions::DrawRainbowLine(MenuSettings::xHud + MenuSettings::menuWidth - 15 - (width / 2), ((data::maxScroll * 20) + MenuSettings::YHud + 34), width / 2, height, grey, rgb_cur == 0 ? red : rgb_cur == 1 ? green : blue);
		menuFunctions::DrawShader(MenuSettings::xHud + MenuSettings::menuWidth - 15 - width + ((width - 4) * col), ((data::maxScroll * 20) + MenuSettings::YHud + 34), 2, height, menuColors::menuMain, "white");

	}
	void DrawIntOption(char* option, float min, float max, int var, char* hint = "no preview") {

		drawOption(option, hint);

		int width = 80;
		int height = 14;
		//	menuFunctions::DrawShader(MenuSettings::xHud + MenuSettings::menuWidth - 25 - width, ((data::maxScroll * 20) + MenuSettings::YHud + 37), 15, 10, menu_grey, "white");
		menuColors::Color grey = { 19 / 255.f, 19 / 255.f, 19 / 255.f, data::menuAlpha };
		const int min_max = max - min;
		const float value_min_delta = var - min;
		const float desired_fraction = (value_min_delta / min_max) * width;
		const float delta = desired_fraction - data::sliderData[data::maxScroll];
		if (desired_fraction != data::sliderData[data::maxScroll])
			data::sliderData[data::maxScroll] += delta * 0.12f;

		menuFunctions::DrawShader(MenuSettings::xHud + MenuSettings::menuWidth - 15 - width, ((data::maxScroll * 20) + MenuSettings::YHud + 34), width, height, grey, "white");
		menuFunctions::DrawShader(MenuSettings::xHud + MenuSettings::menuWidth - 15 - width, ((data::maxScroll * 20) + MenuSettings::YHud + 34), data::sliderData[data::maxScroll], height, menuColors::menuMain, "white");

		char buff[128];
		snprintf(buff, 128, "%i", var);
		Vector2 this_label_size = TextSize(buff, 0.5);
		menuFunctions::DrawText(buff, MenuSettings::xHud + MenuSettings::menuWidth - 15 - width - this_label_size.x - 5, ((data::maxScroll * 20) + MenuSettings::YHud + 49), FONT_NORMAL, 0.5, menuColors::menuWhite);

	}
	void drawCharOption(char* option, const char* selected_option, char* hint = "no preview") {
		drawOption(option, hint);

		menuFunctions::DrawText(selected_option, MenuSettings::xHud + MenuSettings::menuWidth - 15 - TextSize(selected_option, 0.5).x, ((data::maxScroll * 20) + MenuSettings::YHud + 49), FONT_NORMAL, 0.5, menuColors::menuWhite);
	}



	void Scroller() {
		if (MenuSettings::MenuFlash)
		{
			menuFunctions::DrawShader(MenuSettings::xHud, ((data::curScroll[data::ScrollInt] * 20) + MenuSettings::YHud + 31), 400, 22, menuColors::menuDimmedBlack, "white");
			menuFunctions::DrawRainbowLine(MenuSettings::xHud, ((data::curScroll[data::ScrollInt] * 20) + MenuSettings::YHud + 32), 400, 20, menuColors::dflash2, menuColors::dflash);
		}
		else {
			/*menuFunctions::DrawShader(MenuSettings::xHud, ((data::curScroll[data::ScrollInt] * 20) + MenuSettings::YHud + 31), 400, 22, menuColors::menuDimmedBlack, "white");
			menuFunctions::DrawShader(MenuSettings::xHud, ((data::curScroll[data::ScrollInt] * 20) + MenuSettings::YHud + 32), 400, 20, menuColors::menuGrey, "white");*/
			menuFunctions::DrawShader(MenuSettings::xHud, MenuSettings::YHud + 31 + data::scrollData, 400, 22, menuColors::menuDimmedBlack, "white");
			menuFunctions::DrawShader(MenuSettings::xHud, MenuSettings::YHud + 32 + data::scrollData, 400, 20, menuColors::menuGrey, "white");
		}
	}
	void HandleScrollAnimation() {

		// min area
		int min = 0;
		// the max size you'd want
		int max = data::maxOptions;
		// get your min max xD
		int min_max = max - min;
		// create your min delta by taking away the min with your actual value
		const float value_min_delta = data::curScroll[data::ScrollInt] - min;
		// create your fraction by dividing your min delta with your min max and timeing it by your max size you actually want
		const float desired_fraction = (value_min_delta / min_max) * (20 * data::maxOptions);
		static float current_fraction = 0.f;
		// create the delta fraction
		const float delta = desired_fraction - current_fraction;
		// if its not the same animate.
		if (desired_fraction != current_fraction)
			current_fraction += delta * 0.12f;
		data::scrollData = current_fraction;
	}

	void HandleColors() {
		if (menuColors::menuMain.r != menuColors::inputtedColor.r)
		{
			if (menuColors::menuMain.r < menuColors::inputtedColor.r)
				menuColors::menuMain.r += 0.02f;
			else
				menuColors::menuMain.r -= 0.02f;

		}

		if (menuColors::menuMain.g != menuColors::inputtedColor.g)
		{
			if (menuColors::menuMain.g < menuColors::inputtedColor.g)
				menuColors::menuMain.g += 0.02f;
			else
				menuColors::menuMain.g -= 0.02f;
		}

		if (menuColors::menuMain.b != menuColors::inputtedColor.b)
		{
			if (menuColors::menuMain.b < menuColors::inputtedColor.b)
				menuColors::menuMain.b += 0.02f;
			else
				menuColors::menuMain.b -= 0.02f;
		}

	}

	void HandleMenuAlpha() {
		using namespace menuColors;

		menuGrey.a = data::menuAlpha * 0.862f;
		inputtedColor.a = data::menuAlpha;
		menuBlack.a = data::menuAlpha;
		menuDimmedBlack.a = data::menuAlpha * 0.7f;
		menuWhite.a = data::menuAlpha;
		menuDimmedWhite.a = data::menuAlpha;
		Main.r = menuMain.r;
		Main.g = menuMain.g;
		Main.b = menuMain.b;
	}


	void HandleMenuPos() {
		if (!Bools::setMenuPosAuto)
			return;

		const float me_want_this = ((structures::ui_context.screenHeight / 2) - (MenuSettings::menuHeight/2));
		static float me_have_this = MenuSettings::YHud;

		const float delta = me_want_this - me_have_this;

		if (me_want_this != me_have_this)
			me_have_this += delta * 0.12f;

		MenuSettings::YHud = me_have_this;
	}
	void HandleMenuSize() {
	
		const float me_want_this = (MenuSettings::BaseMenuHeight + (20 * data::maxScroll));
		static float me_have_this = MenuSettings::menuHeight;

		const float delta = me_want_this - me_have_this;

		if (me_want_this != me_have_this)
			me_have_this += delta * 0.12f;
		
		MenuSettings::menuHeight = me_have_this;
	}

}

void flashFloat(float* rain)
{

	if (rain[3] <= 0) rain[3] = 1.0;
	if (rain[0] <= 0 && rain[1] <= 0 && rain[2] <= 0)
		rain[0] = 1.0f;
	if (rain[0] > 0 && rain[2] <= 0.15 / 255.00f)
	{
		rain[0] -= 1 / 255.00f;
		rain[1] += 1 / 255.00f;
		rain[3] = rain[3];
	}
	if (rain[1] > 0 && rain[0] <= 0.15 / 255.00f)
	{
		rain[1] -= 1 / 255.00f;
		rain[2] += 1 / 255.00f;
		rain[3] = rain[3];
	}
	if (rain[2] > 0 && rain[1] <= 0.15 / 255.00f)
	{
		rain[0] += 1 / 255.00f;
		rain[2] -= 1 / 255.00f;
		rain[3] = rain[3];
	}
}

void flash(menuColors::Color* rain)
{

	if (rain->a <= 0) rain->a = 1.0;
	if (rain->r <= 0 && rain->g <= 0 && rain->b <= 0)
		rain->r = 1.0f;
	if (rain->r > 0 && rain->b <= 0.15 / 255.00f)
	{
		rain->r -= 1 * MenuSettings::MenuFlashSpeed / 255.00f;
		rain->g += 1 * MenuSettings::MenuFlashSpeed / 255.00f;
		rain->a = rain->a;
	}
	if (rain->g > 0 && rain->r <= 0.15 / 255.00f)
	{
		rain->g -= 1 * MenuSettings::MenuFlashSpeed / 255.00f;
		rain->b += 1 * MenuSettings::MenuFlashSpeed / 255.00f;
		rain->a = rain->a;
	}
	if (rain->b > 0 && rain->g <= 0.15 / 255.00f)
	{
		rain->r += 1 * MenuSettings::MenuFlashSpeed / 255.00f;
		rain->b -= 1 * MenuSettings::MenuFlashSpeed / 255.00f;
		rain->a = rain->a;
	}
}

void flashFaster(menuColors::Color* rain)
{

	if (rain->a <= 0) rain->a = 1.0;
	if (rain->r <= 0 && rain->g <= 0 && rain->b <= 0)
		rain->r = 1.0f;
	if (rain->r > 0 && rain->b <= 0.15 / 255.00f)
	{
		rain->r -= 1.5 * MenuSettings::MenuFlashSpeed / 255.00f;
		rain->g += 1.5 * MenuSettings::MenuFlashSpeed / 255.00f;
		rain->a = rain->a;
	}
	if (rain->g > 0 && rain->r <= 0.15 / 255.00f)
	{
		rain->g -= 1.5 * MenuSettings::MenuFlashSpeed / 255.00f;
		rain->b += 1.5 * MenuSettings::MenuFlashSpeed / 255.00f;
		rain->a = rain->a;
	}
	if (rain->b > 0 && rain->g <= 0.15 / 255.00f)
	{
		rain->r += 1.5 * MenuSettings::MenuFlashSpeed / 255.00f;
		rain->b -= 1.5 * MenuSettings::MenuFlashSpeed / 255.00f;
		rain->a = rain->a;
	}
}


void SetMenu()
{
	//// min area
	//int min = 0;
	//// the max size you'd want
	//int max = data::maxOptions * 20;
	//// get your min max xD
	//int min_max = max - min;
	//// create your min delta by taking away the min with your actual value
	//const float value_min_delta = (MenuSettings::menuHeight - MenuSettings::BaseMenuHeight) - min;
	//// create your fraction by dividing your min delta with your min max and timeing it by your max size you actually want
	//const float desired_fraction = (value_min_delta / min_max) * (data::maxOptions * 20);
	//static float current_fraction = 0.f;
	//// create the delta fraction
	//const float delta = desired_fraction - current_fraction;
	//// if its not the same animate.
	//if (desired_fraction != current_fraction)
	//	current_fraction += delta * 0.18f;

	MenuSettings::menuHeight = MenuSettings::BaseMenuHeight + (20 * data::maxScroll);
}


void RedBox_F()
{
	Bools::RedBox = !Bools::RedBox;
	char BytesOn[] = { 47, 128, 0, 1 };
	char BytesOff[4] = { 47, 28 };
	mainFuncs::writeProcMem(300788U, Bools::RedBox ? BytesOn : BytesOff, sizeof(Bools::RedBox ? BytesOn : BytesOff), true);
}

void UAV_F()
{
	Bools::UAV = !Bools::UAV;
	char BytesOn[] = { 1 };
	char BytesOff[1];
	mainFuncs::writeProcMem(30539524U, Bools::UAV ? BytesOn : BytesOff, sizeof(Bools::UAV ? BytesOn : BytesOff), true);
}


void Laser_F()
{
	Bools::Laser = !Bools::Laser;
	char BytesOn[] = { 57, 64, 0, 1 };
	char BytesOff[4] = { 57, 64 };
	mainFuncs::writeProcMem(575416U, Bools::Laser ? BytesOn : BytesOff, sizeof(Bools::Laser ? BytesOn : BytesOff), true);
}

void Level70_F()
{
	
	char Bytes[] = { 255, 255, 255 };
	mainFuncs::writeProcMem(33528468U, &Bytes, sizeof(Bytes), true);
}
void UnlockAll(int client)
{
	*(char*)(0x01FFA0C7) = 0x0A, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
		0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
		0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
		0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
		0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
		0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
		0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x09, 0x09, 0x02,
		0x02, 0x02, 0x02, 0x02, 0x02, 0x09, 0x09, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
		0x09, 0x09, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x09, 0x09, 0x02, 0x02, 0x02,
		0x02, 0x02, 0x02, 0x09, 0x09, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x09, 0x09,
		0x02, 0x02, 0x02, 0x02, 0x02, 0x09, 0x09, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
		0x09, 0x09, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x09, 0x09, 0x02, 0x02, 0x02,
		0x02, 0x02, 0x02, 0x09, 0x09, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x09, 0x09,
		0x02, 0x02, 0x02, 0x02, 0x09, 0x09, 0x02, 0x02, 0x02, 0x02, 0x09, 0x09, 0x02,
		0x02, 0x02, 0x02, 0x09, 0x09, 0x02, 0x02, 0x02, 0x02, 0x02, 0x09, 0x09, 0x02,
		0x02, 0x02, 0x02, 0x02, 0x09, 0x09, 0x02, 0x02, 0x02, 0x02, 0x02, 0x09, 0x09,
		0x02, 0x02, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
		0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
		0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
		0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
		0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
		0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
		0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
		0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
		0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
		0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
		0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
		0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
		0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
		0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
		0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
		0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
		0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
		0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
		0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
		0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x04, 0x02, 0x04, 0x04, 0x04, 0x02, 0x04,
		0x04, 0x02, 0x02, 0x03, 0x03, 0x03, 0x02, 0x03, 0x05, 0x05, 0x05, 0x05, 0x05,
		0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE8, 0x03, 0x00,
		0x00, 0x0F, 0x40, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00,
		0x0F, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x0A,
		0x00, 0x00, 0x00, 0xE8, 0x03, 0x00, 0x00, 0x0F, 0x40, 0x00, 0x00, 0x14, 0x00,
		0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00,
		0x00, 0x28, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0xE8, 0x03, 0x00, 0x00,
		0x0F, 0x40, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x0F,
		0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x0A, 0x00,
		0x00, 0x00, 0xE8, 0x03, 0x00, 0x00, 0x0F, 0x40, 0x00, 0x00, 0x14, 0x00, 0x00,
		0x00, 0x3C, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00,
		0x28, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0xE8, 0x03, 0x00, 0x00, 0xF4,
		0x30, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x0F, 0x00,
		0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00,
		0x00, 0xE8, 0x03, 0x00, 0x00, 0x0F, 0x40, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00,
		0x0F, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x09,
		0x00, 0x00, 0x00, 0xE8, 0x03, 0x00, 0x00, 0x0F, 0x40, 0x00, 0x00, 0x14, 0x00,
		0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00,
		0x00, 0x28, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0xE8, 0x03, 0x00, 0x00,
		0x0F, 0x40, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x0F,
		0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x0A, 0x00,
		0x00, 0x00, 0xE8, 0x03, 0x00, 0x00, 0x0F, 0x40, 0x00, 0x00, 0x14, 0x00, 0x00,
		0x00, 0x3C, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00,
		0x28, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0xE8, 0x03, 0x00, 0x00, 0x0F,
		0x40, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x0F, 0x00,
		0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00,
		0x00, 0xE8, 0x03, 0x00, 0x00, 0x0F, 0x40, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00,
		0x14, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0xE8,
		0x03, 0x00, 0x00, 0x0F, 0x40, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x14, 0x00,
		0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0xE8, 0x03, 0x00,
		0x00, 0x0F, 0x40, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00,
		0x28, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0xE8, 0x03, 0x00, 0x00, 0x0F,
		0x40, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x14, 0x00,
		0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0xE8, 0x03, 0x00,
		0x00, 0x0F, 0x40, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00,
		0x14, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0xE8,
		0x03, 0x00, 0x00, 0x0F, 0x40, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x3C, 0x00,
		0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00,
		0x00, 0xE8, 0x03, 0x00, 0x00, 0x0F, 0x40, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00,
		0x3C, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x09,
		0x00, 0x00, 0x00, 0xE8, 0x03, 0x00, 0x00, 0x0F, 0x40, 0x00, 0x00, 0x1E, 0x00,
		0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00,
		0x00, 0x09, 0x00, 0x00, 0x00, 0xE8, 0x03, 0x00, 0x00, 0x0F, 0x40, 0x00, 0x00,
		0x0F, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x28,
		0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0xE8, 0x03, 0x00, 0x00, 0x0F, 0x40,
		0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00,
		0x00, 0x28, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0xE8, 0x03, 0x00, 0x00,
		0x0F, 0x40, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x14,
		0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0xE8, 0x03,
		0x00, 0x00, 0x0F, 0x40, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00,
		0x00, 0x28, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x0F, 0x40, 0x00, 0x00,
		0xE8, 0x03, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x14,
		0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0xE8, 0x03,
		0x00, 0x00, 0x0F, 0x40, 0x00, 0x00, 0xE8, 0x03, 0x00, 0x00, 0x0F, 0x40, 0x00,
		0x00, 0xE8, 0x03, 0x00, 0x00, 0x0F, 0x40, 0x00, 0x00, 0xE8, 0x03, 0x00, 0x00,
		0x0F, 0x40, 0x00, 0x00, 0xE8, 0x03, 0x00, 0x00, 0x0F, 0x40, 0x00, 0x00, 0xE8,
		0x03, 0x00, 0x00, 0x0F, 0x40, 0x00, 0x00, 0xE8, 0x03, 0x00, 0x00, 0x0F, 0x40,
		0x00, 0x00, 0xE8, 0x03, 0x00, 0x00, 0x0F, 0x40, 0x00, 0x00, 0xC4, 0x09, 0x00,
		0x00, 0x0F, 0x40, 0x00, 0x00, 0xC4, 0x09, 0x00, 0x00, 0x0F, 0x40, 0x00, 0x00,
		0xE8, 0x03, 0x00, 0x00, 0x0F, 0x40, 0x00, 0x00, 0xE8, 0x03, 0x00, 0x00, 0x0F,
		0x40, 0x00, 0x00, 0xC4, 0x09, 0x00, 0x00, 0x0F, 0x40, 0x00, 0x00, 0xC4, 0x09,
		0x00, 0x00, 0x0F, 0x40, 0x00, 0x00, 0xB0, 0x04, 0x00, 0x00, 0xB0, 0x04, 0x00,
		0x00, 0xB0, 0x04, 0x00, 0x00, 0xB0, 0x04, 0x00, 0x00, 0xFA, 0x00, 0x00, 0x00,
		0x00, 0x61, 0x08, 0x00, 0x0F, 0x40, 0x00, 0x00, 0xFA, 0x00, 0x00, 0x00, 0xFA,
		0x00, 0x00, 0x00, 0xEE, 0x02, 0x00, 0x00, 0x84, 0x03, 0x00, 0x00, 0xE8, 0x03,
		0x00, 0x00, 0xFA, 0x00, 0x00, 0x00, 0xEE, 0x02, 0x00, 0x00, 0xFA, 0x00, 0x00,
		0x00, 0x64, 0x00, 0x00, 0x00, 0x0F, 0x40, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00,
		0xEE, 0x02, 0x00, 0x00, 0x40, 0x24, 0x14, 0x00, 0x0F, 0x40, 0x00, 0x00, 0x32,
		0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x32, 0x00,
		0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00,
		0x00, 0x32, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00,
		0x19, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0x0A,
		0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0xE8, 0x03, 0x00, 0x00, 0xE8, 0x03,
		0x00, 0x00, 0xE8, 0x03, 0x00, 0x00, 0xE8, 0x03, 0x00, 0x00, 0x32, 0x00, 0x00,
		0x00, 0x1E, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00,
		0x32, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0xFF,
		0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0xFF, 0x00,
		0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00,
		0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00,
		0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00,
		0xFF, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF,
		0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xC8, 0x00,
		0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00,
		0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00,
		0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF,
		0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00,
		0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00,
		0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00,
		0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x1E,
		0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x0F, 0x00,
		0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00,
		0x00, 0x50, 0xC3, 0x00, 0x00, 0x50, 0xC3, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00,
		0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF,
		0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x32, 0x00,
		0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00,
		0x00, 0x32, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00,
		0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF,
		0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x19, 0x00,
		0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00,
		0x00, 0xFF, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00,
		0xFF, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01,
		0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01,
		0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00,
		0x00, 0x01, 0x01, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00,
		0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01,
		0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01,
		0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00,
		0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00,
		0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01,
		0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01,
		0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00,
		0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00,
		0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01,
		0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0xC8, 0x00, 0x00, 0x00, 0xFF, 0x00,
		0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00,
		0x00, 0xFF, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00,
		0x0A, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0A,
		0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x0A, 0x00,
		0x00, 0x00, 0xFA, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0xE8, 0x03, 0x00,
		0x00, 0x2C, 0x00, 0x00, 0x00, 0x2C, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00,
		0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x13, 0x00, 0x18,
		0x00, 0x00, 0x00, 0x67, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFA,
		0xFF, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xBF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78,
		0xDD, 0x99, 0x03;
}
void UnlockAll_F()
{
	//mainFuncs::writeProcMem(0x001EA260, "38 60 00 01 4E 80 00 20", sizeof("38 60 00 01 4E 80 00 20"), true);
	char Bytes1[] = { 255, 255, 255 };
	char Bytes2[] = { 255 };
	mainFuncs::writeProcMem(33528468U, Bytes1, sizeof(Bytes1), true);
	mainFuncs::writeProcMem(67060590U, Bytes2, sizeof(Bytes2), true);
	UnlockAll(0);
}

void MaxPrestige_F()
{
	if (Bools::setPrestige == 10)
		Bools::setPrestige = 0;
	else
		Bools::setPrestige++;

	char Bytes[] = { Bools::setPrestige, 0 };
	mainFuncs::writeProcMem(33528476U, &Bytes, sizeof(Bytes), true);
}

void Wallhack_F()
{
	Bools::Wallhack = !Bools::Wallhack;
	const char* On = "r_znear 55";
	const char* Off = "r_znear 5";
	pointers::Cbuf_AddText(0, Bools::Wallhack ? On : Off);
}

void NOSpread_F()
{
	Bools::NoSpread = !Bools::NoSpread;
	const char* On = "perk_weapSpreadMultiplier 0.0001";
	const char* Off = "perk_weapSpreadMultiplier 0.62";
	//pointers::Cbuf_AddText(0, Bools::NoSpread ? On : Off);

	char BytesOn[4] = { 96 };
	char BytesOff[] = { 75, 250, 16, 245 };
	mainFuncs::writeProcMem(603180U, Bools::NoSpread ? BytesOn : BytesOff, sizeof(Bools::NoSpread ? BytesOn : BytesOff), true);
}

void SayZeroTwoPW()
{
	pointers::Cbuf_AddText(0, "say ^6ZeroTwo.pw");
}

void SayRetards()
{
	pointers::Cbuf_AddText(0, "say bonk");
}

void SaySubToZeroTwoHvH()
{
	pointers::Cbuf_AddText(0, "say Get Boofed Kid");
}

void SayLoLNooB()
{
	pointers::Cbuf_AddText(0, "say okey");
}

void SayHENFTW()
{
	pointers::Cbuf_AddText(0, "say hen yes");
}

void SayFukUParabonx()
{
	pointers::Cbuf_AddText(0, "say ^1fuk u parabonx");
}

void SayOhNoAModder()
{
	pointers::Cbuf_AddText(0, "say fuck outa here bruh");
}

void SayGetGudKid()
{
	pointers::Cbuf_AddText(0, "say y'know i have a clients menu with your name and ip on it?");
}

void FOV_F()
{
	Bools::FOV = !Bools::FOV;
	const char* On = "cg_fov 100";
	const char* Off = "cg_fov 65";
	pointers::Cbuf_AddText(0, Bools::FOV ? On : Off);
}

void NoFX_F()
{
	Bools::NoFX = !Bools::NoFX;
	const char* On = "fx_enable 0";
	const char* Off = "fx_enable 1";
	pointers::Cbuf_AddText(0, Bools::NoFX ? On : Off);
}

void ThirdPerson_F()
{
	Bools::ThirdPerson = !Bools::ThirdPerson;

	*(bool*)(0x1D13508 + 0xC) = Bools::ThirdPerson;
}

void MapRotation_F()
{
	Bools::MapRotation = !Bools::MapRotation;
	const char* On = "compassRotation 0";
	const char* Off = "compassRotation 1";
	pointers::Cbuf_AddText(0, Bools::MapRotation ? On : Off);
}

void L33T_F()
{
	Bools::L33T = !Bools::L33T;
	char On[1] = { 0x41 };
	char On1[1] = { 0x40 };
	char Off[1] = { 0x40 };
	char Off1[1] = { 0x41 };
	mainFuncs::writeProcMem(0x244BDC, Bools::L33T ? On : Off, 1, true);
	mainFuncs::writeProcMem(0x2534E8, Bools::L33T ? On1 : Off1, 1, true);
}

void ForceHost_F()
{
	Bools::ForceHost = !Bools::ForceHost;
	const char* On = "reset party_autoteams;xblive_privatematch 0;xblive_rankedmatch 1;disconnect;killserver;disconnect;xstartlobby;set party_connectToOthers 0;xsearchforgames;wait 200;xsearchforgames;set party_hostmigration 0;set party_gameStartTimerLength 1;set party_pregameStartTimerLength 1;set party_timer 1;set party_minplayers 2;wait 200;reset party_autoteams;xsearchforgames;";
	const char* Off = "vstr FHF;";
	pointers::Cbuf_AddText(0, Bools::ForceHost ? On : Off);
}
void crashHost() {
	char* d = "aa ^";
	//*(char*)(0x1D17B10 + 0xC) = *d;
	pointers::Cbuf_AddText(0, "userinfo \"\\name\\aa ^\";wait 10;disconnect");
}


void ClassNames()
{
	WriteString(0x01ff9e6c, "^6ZeroTwo.pw    ");
	WriteString(0x01ff9eac, "^5ZeroTwo.pw    ");
	WriteString(0x1FF9EEC, "^6ZeroTwo.pw    ");
	WriteString(0x1FF9F2C, "^5ZeroTwo.pw    ");
	WriteString(0x1FF9F6C, "^6ZeroTwo.pw    ");
	WriteString(0x1FF9FAC, "^5ZeroTwo.pw    ");
	WriteString(0x1FF9FEC, "^6ZeroTwo.pw    ");
	WriteString(0x1FFA02C, "^5ZeroTwo.pw    ");
	WriteString(0x1FFA06C, "^6ZeroTwo.pw    ");
	WriteString(0x1FFA0AC, "^5ZeroTwo.pw    ");
}
structures::opd_s SV_GameSendServerCommand_t = { 0x0021A0A0, TOC };
void(*SV_GameSendServerCommand)(int clientIndex, int type, const char* Command) = (void(*)(int, int, const char*)) & SV_GameSendServerCommand_t;



void SpoofIP()
{
	char Spoof[] = { 1, 3, 3, 7 };
	mainFuncs::writeProcMem((uint32_t)0xA1359A * 328, Spoof, sizeof(Spoof), true);
}

void SetNoSway()
{
	Bools::NoSway = !Bools::NoSway;
	unsigned char byteON[4] = { 0x60, 0x00, 0x00, 0x00 };
	unsigned char byteOFF[4] = { 0xD3, 0xFB, 0x00, 0x00 };
	unsigned char byteOFF2[4] = { 0xD0, 0x3A, 0x00, 0x00 };
	unsigned char byteOFF3[4] = { 0xD3, 0xF7, 0x00, 0x00 };
	unsigned char byteOFF4[4] = { 0xD0, 0x3C, 0x00, 0x00 };
	unsigned char byteOFF5[4] = { 0xD0, 0x3B, 0x00, 0x00 };
	mainFuncs::writeProcMem(0x36018, Bools::NoSway ? byteON : byteOFF, 4, true);
	mainFuncs::writeProcMem(0x35FE4, Bools::NoSway ? byteON : byteOFF2, 4, true);
	mainFuncs::writeProcMem(0x36C80, Bools::NoSway ? byteON : byteOFF3, 4, true);
	mainFuncs::writeProcMem(0x36C4C, Bools::NoSway ? byteON : byteOFF4, 4, true);
	mainFuncs::writeProcMem(0x36C10, Bools::NoSway ? byteON : byteOFF5, 4, true);
}

void removeFog_F() {
	Bools::removeFog = !Bools::removeFog;

	//pointers::Cbuf_AddText(0, Bools::removeFog ? "r_fog 0" : "r_fog 1");
	*(bool*)(0x1D0CE60 + 0xC) = !Bools::removeFog;
}
void fullbright_F() {
	Bools::fullbright = !Bools::fullbright;

	*(bool*)(0x1D0CC68 + 0xC) = Bools::fullbright;
	//pointers::Cbuf_AddText(0, Bools::fullbright ? "r_fullbright 1" : "r_fullbright 0");
}

void noFlinch_F() {
	Bools::noFlinch = !Bools::noFlinch;

	*(float*)(0x1D21AD0 + 0xC) = Bools::noFlinch ? 0 : 500;
}

bool Content_IsDLC1Installed()
{
	return !strcmp(contentPack->dlcName1, "DLC_1") || !strcmp(contentPack->dlcName2, "DLC_1");
}

bool Content_IsDLC2Installed()
{
	return !strcmp(contentPack->dlcName1, "DLC_2") || !strcmp(contentPack->dlcName2, "DLC_2");
}

bool Content_IsAnyDLCPackInstalled()
{
	return Content_IsDLC1Installed() || Content_IsDLC2Installed();
}

int Content_GetInstalledDLCContentPackIndex()
{
	if (Content_IsDLC1Installed() && Content_IsDLC2Installed())
		return 3;
	else if (Content_IsDLC1Installed() || Content_IsDLC2Installed())
		return 2;
	else
		return 1;
}
void DisableDlc()
{
	if (Content_IsAnyDLCPackInstalled())
	{
		Bools::disableDLC = !Bools::disableDLC;
		if (Bools::disableDLC)
		{
			contentPack->contentPack = 1;

		}
		else
		{
			contentPack->contentPack = Content_GetInstalledDLCContentPackIndex();

		}
	}

}
